import fs from 'fs';
import path from 'path';
import { EnvVariable, EnvConfig, defaultEnvVariables } from './types';

const ENV_FILE_PATH = path.join(process.cwd(), '.env');
const ENV_BACKUP_DIR = path.join(process.cwd(), '.env.backup');

/**
 * Parse .env file content to key-value pairs
 */
export function parseEnvFile(content: string): Record<string, string> {
  const env: Record<string, string> = {};
  
  const lines = content.split('\n');
  
  for (const line of lines) {
    // Skip comments and empty lines
    if (line.trim().startsWith('#') || line.trim() === '') {
      continue;
    }
    
    // Parse KEY=VALUE
    const match = line.match(/^([^=]+)=(.*)$/);
    if (match) {
      const key = match[1].trim();
      let value = match[2].trim();
      
      // Remove quotes if present
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }
      
      env[key] = value;
    }
  }
  
  return env;
}

/**
 * Read current .env file
 */
export async function readEnvFile(): Promise<Record<string, string>> {
  try {
    if (!fs.existsSync(ENV_FILE_PATH)) {
      return {};
    }
    
    const content = fs.readFileSync(ENV_FILE_PATH, 'utf-8');
    return parseEnvFile(content);
  } catch (error) {
    console.error('Error reading .env file:', error);
    throw new Error('Failed to read .env file');
  }
}

/**
 * Get current environment configuration
 */
export async function getEnvConfig(): Promise<EnvConfig> {
  const envValues = await readEnvFile();
  
  // Merge default variables with current values
  const variables: EnvVariable[] = defaultEnvVariables.map(defaultVar => ({
    ...defaultVar,
    value: envValues[defaultVar.key] || defaultVar.value || '',
  }));
  
  // Add any extra variables not in defaults
  Object.entries(envValues).forEach(([key, value]) => {
    if (!defaultEnvVariables.find(v => v.key === key)) {
      variables.push({
        key,
        value,
        category: 'other',
        description: 'Custom environment variable',
        isSecret: false,
        isPublic: key.startsWith('NEXT_PUBLIC_'),
        isRequired: false,
        order: 999,
      });
    }
  });
  
  // Sort by order
  variables.sort((a, b) => a.order - b.order);
  
  return {
    variables,
    lastUpdated: new Date().toISOString(),
  };
}

/**
 * Generate .env file content from variables
 */
export function generateEnvFileContent(variables: EnvVariable[]): string {
  let content = '# Environment Variables\n';
  content += `# Last updated: ${new Date().toISOString()}\n`;
  content += '# Generated by Admin Panel\n\n';
  
  // Group by category
  const grouped = variables.reduce((acc, variable) => {
    if (!acc[variable.category]) {
      acc[variable.category] = [];
    }
    acc[variable.category].push(variable);
    return acc;
  }, {} as Record<string, EnvVariable[]>);
  
  // Write each category
  Object.entries(grouped).forEach(([category, vars]) => {
    content += `# ${category.toUpperCase()}\n`;
    
    vars.forEach(variable => {
      if (variable.description) {
        content += `# ${variable.description}\n`;
      }
      if (variable.example) {
        content += `# Example: ${variable.example}\n`;
      }
      
      // Format value (add quotes if contains spaces or special chars)
      let value = variable.value;
      if (value.includes(' ') || value.includes('#') || value.includes('$')) {
        value = `"${value}"`;
      }
      
      content += `${variable.key}=${value}\n`;
      content += '\n';
    });
  });
  
  return content;
}

/**
 * Backup current .env file
 */
export async function backupEnvFile(): Promise<string> {
  try {
    if (!fs.existsSync(ENV_FILE_PATH)) {
      throw new Error('.env file not found');
    }
    
    // Create backup directory if not exists
    if (!fs.existsSync(ENV_BACKUP_DIR)) {
      fs.mkdirSync(ENV_BACKUP_DIR, { recursive: true });
    }
    
    // Generate backup filename with timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(ENV_BACKUP_DIR, `.env.${timestamp}`);
    
    // Copy file
    fs.copyFileSync(ENV_FILE_PATH, backupPath);
    
    // Keep only last 10 backups
    const backups = fs.readdirSync(ENV_BACKUP_DIR)
      .filter(f => f.startsWith('.env.'))
      .sort()
      .reverse();
    
    if (backups.length > 10) {
      backups.slice(10).forEach(backup => {
        fs.unlinkSync(path.join(ENV_BACKUP_DIR, backup));
      });
    }
    
    return backupPath;
  } catch (error) {
    console.error('Error backing up .env file:', error);
    throw new Error('Failed to backup .env file');
  }
}

/**
 * Save environment configuration
 */
export async function saveEnvConfig(
  config: EnvConfig,
  options?: { createBackup?: boolean }
): Promise<void> {
  try {
    // Create backup first if requested
    if (options?.createBackup) {
      await backupEnvFile();
    }
    
    // Generate new content
    const content = generateEnvFileContent(config.variables);
    
    // Write to file
    fs.writeFileSync(ENV_FILE_PATH, content, 'utf-8');
    
    console.log('.env file updated successfully');
  } catch (error) {
    console.error('Error saving .env file:', error);
    throw new Error('Failed to save .env file');
  }
}

/**
 * Add new environment variable
 */
export async function addEnvVariable(variable: EnvVariable): Promise<void> {
  const config = await getEnvConfig();
  
  // Check if key already exists
  if (config.variables.find(v => v.key === variable.key)) {
    throw new Error(`Environment variable ${variable.key} already exists`);
  }
  
  config.variables.push(variable);
  await saveEnvConfig(config, { createBackup: true });
}

/**
 * Update environment variable
 */
export async function updateEnvVariable(
  key: string,
  updates: Partial<EnvVariable>
): Promise<void> {
  const config = await getEnvConfig();
  
  const index = config.variables.findIndex(v => v.key === key);
  if (index === -1) {
    throw new Error(`Environment variable ${key} not found`);
  }
  
  config.variables[index] = {
    ...config.variables[index],
    ...updates,
  };
  
  await saveEnvConfig(config, { createBackup: true });
}

/**
 * Delete environment variable
 */
export async function deleteEnvVariable(key: string): Promise<void> {
  const config = await getEnvConfig();
  
  config.variables = config.variables.filter(v => v.key !== key);
  
  await saveEnvConfig(config, { createBackup: true });
}

/**
 * List backup files
 */
export async function listBackups(): Promise<string[]> {
  try {
    if (!fs.existsSync(ENV_BACKUP_DIR)) {
      return [];
    }
    
    return fs.readdirSync(ENV_BACKUP_DIR)
      .filter(f => f.startsWith('.env.'))
      .sort()
      .reverse();
  } catch (error) {
    console.error('Error listing backups:', error);
    return [];
  }
}

/**
 * Restore from backup
 */
export async function restoreFromBackup(backupFilename: string): Promise<void> {
  try {
    const backupPath = path.join(ENV_BACKUP_DIR, backupFilename);
    
    if (!fs.existsSync(backupPath)) {
      throw new Error('Backup file not found');
    }
    
    // Backup current file before restore
    await backupEnvFile();
    
    // Restore
    fs.copyFileSync(backupPath, ENV_FILE_PATH);
    
    console.log('Restored from backup:', backupFilename);
  } catch (error) {
    console.error('Error restoring from backup:', error);
    throw new Error('Failed to restore from backup');
  }
}
